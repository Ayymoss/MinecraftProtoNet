using System.Buffers.Binary;
using System.ComponentModel.DataAnnotations;
using System.Security.Cryptography;
using System.Text;
using MinecraftProtoNet.Attributes;
using MinecraftProtoNet.Core;
using MinecraftProtoNet.Packets.Base;
using MinecraftProtoNet.Services;
using MinecraftProtoNet.Utilities;

namespace MinecraftProtoNet.Packets.Play.Serverbound;

[Packet(0x07, ProtocolState.Play)]
public class ChatPacket : IServerboundPacket
{
    /*

     TODO: Chat Signing

      yossarian2 — 2025-04-18 19:18
      I figured out the new chat system and implemented it on the client side. I agree it's super annoying
      I will see about improving the docs
      Amos are you writing a client or a server? The client has a pretty easy job, I think.
      The server has more of a mess to deal with because of tracking of who has seen what

      Amos ayymoss — 2025-04-18 20:22
      Just a couple of questions.
      1. Where do I get the 'chat' private key from? Is this generated by the client? If so, where do I upload the public key?
      2. Is the public key for ChatSessionUpdate the same key pair to use for Chat signing?
      3. Looking that official client exchange, does ChatSessionUpdate get sent right after switching to Play?
      4. For Chat, the number of messages last seen, is this validated in any way? Could I just send 0 with no messages? I just want to get it working for now, I'll sort out tracking at some point.
      5. This may be a bad question, but Chat Signature is 256 bytes? If we also pass in the message itself, do we need to sanitise the length of the message to conform within the expected byte length?

      yossarian2 — 2025-04-18 20:27
      1. https://api.minecraftservices.com/player/certificates
      2. Yes
      3. Yes
      4. It can be zero right after you join, so as long as you send a chat message before receiving anything, you won't even be breaking any rules.
         After you start receiving signed chat messages, I'm not sure if the server looks a the timestamps and realizes you're lying about not seeing anything.
      5. SHA256 signatures are always exactly 256 bytes. This has nothing to do with the length limit of the chat content which is between 1-256 bytes.

      Tracking seen messages is easier than it sounds. You just need a list of signatures and an integer counting unacknowledged messages.
      Each time you receive a signed message, you append the signature to the list. If the list exceeds 20 elements, you drop the first one.
      Then you increment the count of unacknowledged messages. Each time you send a signed chat message you transmit the unacknowledged messages count and reset the counter to zero.
      That's all you need to do unless you want to handle the delete message packet, which requires modifying the signature list directly.


      // SPEC
      The signature used to verify the chat message's authentication. When present, always 256 bytes and not length-prefixed.
      This is a SHA256 with RSA digital signature computed over the following:
      
      The number 1 as a 4-byte int. Always 00 00 00 01.
      The player's 16 byte UUID.
      The chat session (a 16 byte UUID generated randomly generated by the client).
      The index of the message within this chat session as a 4-byte int. First message is 0, next message is 1, etc. Incremented each time the client sends a chat message.
      The salt (from above) as a 8-byte long.
      The timestamp (from above) converted from millisecods to seconds, so divide by 1000, as a 8-byte long.
      The length of the message in bytes (from above) as a 4-byte int.
      The message bytes.
      The number of messages in the last seen set, as a 4-byte int. Always in the range [0,20].
      For each message in the last seen set, from oldest to newest, the 256 byte signature of that message.
      
      The client's chat private key is used for the message signature.

     */

    public ChatPacket(string message)
    {
        Message = message;
        Timestamp = TimeProvider.System.GetLocalNow().ToUnixTimeMilliseconds();
        Salt = 0;
        Signature = null;
        MessageCount = 0;
        Acknowledged = [0, 0, 0];
    }

    public ChatPacket()
    {
    }

    [MaxLength(256)] public string Message { get; set; }
    public long Timestamp { get; set; }
    public long Salt { get; set; }

    /// <summary>
    /// This needs to be 256 bytes long
    /// </summary>
    [MinLength(256)]
    public byte[]? Signature { get; set; }

    public int MessageCount { get; set; }
    public byte[] Acknowledged { get; set; } = [0, 0, 0];
    public byte Checksum { get; set; }

    public void Serialize(ref PacketBufferWriter buffer)
    {
        buffer.WriteString(Message);
        buffer.WriteSignedLong(Timestamp);
        buffer.WriteSignedLong(Salt);

        if (Signature is not null)
        {
            buffer.WriteBoolean(true);
            buffer.WriteBuffer(Signature);
        }
        else
        {
            buffer.WriteBoolean(false);
        }

        buffer.WriteVarInt(MessageCount);
        buffer.WriteBuffer(Acknowledged);
        buffer.WriteUnsignedByte(Checksum);
    }
}
